1. Ограничитель Primary Key. Foreign key
2. SQl и MySQL различия
3. Подмножества SQL (DDL, DML, DCL, TCL)
4. Какие СУБД есть
5. ТИпы СУБД
6. JOIN/SELECT
7. CHAR/VARCHAR			nvarchr
8. Каскадные операции
9. ограничения 
10. ПРЕДСТАВЛЕНИЯ (View)
11. целостность данных
12. Что такое таблица?
13. вывести текущую дату 
14. денормализация данных
15. нормализация данных
16. Сущности в БД
17. типы индексов.
18. разница между кластеризованным и некластеризованным индексами в SQL?
19. отличия DROP DELETE TRANCATE   (DROP — удаляет, TRUNCATE — очищает.)
20. свойства АСИД (атомарность согласованность изолированность долговечность(стойкость))
21. операторы доступные в SQL
22. равны ли  NULL   0    и пробел
23. декомпозиция
24. подзапросы в SQL. типы подзапросов
25. ANY(SOME), ALL
26. вывести количество строк в таблице базы данных
27. Что вы подразумеваете под «триггером» в SQL?
28. Что делают псевдонимы Aliases?
29. Как выбрать записи с нечётными Id?
30. Выберите только уникальные имена
31. Переименуйте таблицу
32. Что такое нулевое значение? (NULL)
33. Транзакции
34. СУБД
35.	Сравнение SQL и NoSQL
36. Хранимые процедуры 
37. тип хранения данных MyISAM или InnoDB
38. Что такое уникальный ключ (Unique key)?
39. Что такое сущности и отношения?
40. изменение данных в таблице
41. операторы CRUD в SQL
42. агрегатные ф-ии 
43. Операторы фильтрации



==============================================================================================================================









База данных - набор взаимосвязанныз данных,
система хранения данных в упорядоченном виде
СУБД - комплекс програмных средств для управления бд


0. DB (Data Base) база данных
База данных — это упорядоченный набор структурированной информации или данных, 
которые обычно хранятся в электронном виде в компьютерной системе
Стоит различать СУБД и БД

			модели баз данных(самые распостраненные)
Простые структуры данных
	простейший способ хранения данных – текстовые файлы. Метод применяется и сегодня для работы 
	с небольшими объёмами информации. Для разделения полей используется специальный символ: 
	запятая или точка с запятой в csv-файлах датасетов, двоеточие или пробел в *nix-подобных системах:

Иерархическая
каждый объект при таком хранение информации представляется в виде определенной сущности, 
то есть, у этой сущности могут быть дочерние элементы, родительские элементы, а у тех дочерних 
могут быть еще дочерние элементы, но есть один объект, с которого все начинается. 
Получается своеобразное дерево. Примером иерархической базы данных может быть, 
файловая система компьютера,
	информация организована в виде древовидной структуры с отношениями «предок-потомок»;
	каждая запись может иметь не более одного родителя;
	связи между записями выполнены в виде физических указателей;
	невозможно реализовать отношения «многих-ко-многим».

Сетевая
являются своеобразной модификацией иерархических баз данных.
	Сетевые базы данных расширяют функциональность иерархических: записи могут иметь более 
	одного родителя. А значит, можно моделировать сложные отношения.

Реляционная
набор таблиц хранящихся в одном пространстве, связаных между собой
	поле в таблице, называемое внешним ключом, может содержать ссылки на столбцы в других таблицах, 
	что позволяет их соединять;
	высокоорганизованная структура и гибкость делает реляционные БД мощными и адаптируемыми 
	ко различным типам данных;
	для доступа к данным используется язык структурированных запросов (SQL);
	надёжный выбор для многих приложений.


отношения в БД
1 ко многим 
1 ко 1 (каждая запись 1ой таблицы соответствует 1ой записи из другой табл)
многие к 1
многие ко многим








1. Ограничитель Primary Key. Foreign key

SQL ограничение – это любое правило, применяемое к столбцу или таблице, которое определяет, какие данные можно в него вносить, а какие – нет
PRIMARY KEY - первичный ключ, ограничение, позволяющее однозначно идентифицировать каждую запись в таблице SQL
Первичные ключи должны содержать UNIQUE значения и не могут содержать значения NULL.
В таблице может быть только один первичный ключ, который может состоять из одного или нескольких полей.

Первичный ключ (Primary Key )
Обычно таким ключом является ID, идентификатор записи.
отвечает за то, чтобы каждое значение в поле было уникальным, никаких дублей. 
При попытке добавить в таблицу запись с неуникальным первичным ключом получаешь ошибку
его делаюта автоинкрементальным — это значит, что он генерируется сам по алгоритму 
«прошлое значение + 1».

свойства

Ограничение PRIMARY KEY однозначно идентифицирует каждую запись в таблице базы данных. Первичные ключи должны содержать UNIQUE значения и не могут содержать значения NULL.
В таблице может быть только один первичный ключ, который может состоять из одного или нескольких полей.

уникальный
NOt Null
автоинкремент

CREATE TABLE Customers
(
    Id SERIAL PRIMARY KEY,
    FirstName CHARACTER VARYING(30),
    Age INTEGER
)


CREATE TABLE Customers
(
    Id SERIAL,
    FirstName CHARACTER VARYING(30),
    PRIMARY KEY(Id)
);




Foreign Key

Внешние ключи позволяют установить связи между таблицами. Внешний ключ устанавливается для поля (или набора полей)  из зависимой, подчиненной таблицы, и указывает на один из столбцов из главной таблицы. Как правило, внешний ключ указывает на первичный ключ из связанной главной таблицы.
Таблица, содержащая внешний ключ, называется дочерней таблицей, а таблица, содержащая ключ кандидат, называется ссылочной или родительской таблицей.
FOREIGN KEY -  гарантирует ссылочную целостность между родительской и дочерней таблицами

Вторичный ключ (foreign key, внешний ключ.)
не обязателен
используется для связи таблиц между собой в бд


CREATE TABLE Orders
(
    Id SERIAL PRIMARY KEY,
    CustomerId INTEGER REFERENCES Customers (Id),
    Quantity INTEGER
);


CREATE TABLE Orders
(
    Id SERIAL PRIMARY KEY,
    CustomerId INTEGER,
    Quantity INTEGER,
    FOREIGN KEY (CustomerId) REFERENCES Customers (Id)
);











2. SQl и MySQL различия


SQL -  БД
MySql- СУБД

SQL
Structured Query Language — НЕПРОЦЕДУРНЫЙ «язык структурированных запросов»
язык програмирования структурированных запросов
декларативный язык программирования, применяемый для создания, модификации и управления 
данными в реляционной базе данных, управляемой соответствующей системой управления базами данных.

изначальный набор операций SQL:
	создание в базе данных новой таблицы;
	добавление в таблицу новых записей;
	изменение записей;
	удаление записей;
	выборка записей из одной или нескольких таблиц (в соответствии с заданным условием);
	изменение структур таблиц.
со временем язык SQL усложнился

на основе SQL строятся СУБД(система управленя базой данных)
	MySql
	MS SQL
	Oracle
	Postgre Sql
	MongoDB










3. Подмножества SQL (DDL, DML, DCL, TCL)

язык SQL представляет собой набор операторов, которые делятся на определенные группы и у каждой группы есть свое назначение. В сокращенном виде эти группы называются DDL, DML, DCL и TCL

Data Definition Language (DDL) – это группа операторов определения данных 
(создаем, изменяем и удаляем)
- CREATE – используется для создания объектов базы данных;
- ALTER – используется для изменения объектов базы данных;
- DROP – используется для удаления объектов базы данных

Data Manipulation Language (DML) – это группа операторов для манипуляции данными
- SELECT – осуществляет выборку данных;
- INSERT – добавляет новые данные;
- UPDATE – изменяет существующие данные;
- DELETE – удаляет данные.

Data Control Language (DCL) – группа операторов определения доступа к данным
- GRANT – предоставляет пользователю или группе разрешения на определённые операции с объектом;
- REVOKE – отзывает выданные разрешения;
- DENY– задаёт запрет, имеющий приоритет над разрешением.

Transaction Control Language (TCL) – группа операторов для управления транзакциями.
Транзакция – это команда или блок команд (инструкций), которые успешно завершаются как единое целое, при этом в базе данных все внесенные изменения фиксируются на постоянной основе или отменяются
- BEGIN TRANSACTION – служит для определения начала транзакции;
- COMMIT TRANSACTION – применяет транзакцию;
- ROLLBACK TRANSACTION – откатывает все изменения, сделанные в контексте текущей транзакции;
- SAVE TRANSACTION – устанавливает промежуточную точку сохранения внутри транзакции.










4. Какие СУБД есть

SQL
	MySQL,
	PostgreSQL
	Microsoft SQL Server.	
	Oracle

NoSQL (NO only SQL. не только SQL)
	DynamoDB
	Redis
	DB2
	Microsoft Access









5. ТИпы СУБД


	СУБД по типу хранящихся в них данных
-Реляционные
-Ключ-значение
-Документные
-Графовые
-Колоночные

Реляционные, которые поддерживают установку связей между таблицами с помощью первичных и внешних ключей. Пример — MySQL.
Flat File — базы данных с двумерными файлами, в которых содержатся записи одного типа и отсутствует связь с другими файлами, как в реляционных. Пример — Excel.
Иерархические подразумевают наличие записей, связанных друг с другом по принципу отношений один-к-одному или один-ко-многим. А вот для отношений многие-ко-многим следует использовать реляционную модель. Пример — Adabas.
Сетевые похожи на иерархические, но в этом случае «ребёнок» может иметь несколько «родителей» и наоборот. Примеры — IDS и IDMS.
Объектно-ориентированные СУБД работают с базами данных, которые состоят из объектов, используемых в ООП. Объекты группируются в классы и называются экземплярами, а классы в свою очередь взаимодействуют через методы. Пример — Versant.
Объектно-реляционные обладают преимуществами реляционной и объектно-ориентированной моделей. Пример — IBM Db2.
Многомерная модель является разновидностью реляционной и использует многомерные структуры. Часто представляется в виде кубов данных. Пример — Oracle Essbase.
Гибридные состоят из двух и более типов баз данных. Используются в том случае, если одного типа недостаточно для обработки всех запросов. Пример — Altibase HDВ.








6. JOIN/SELECT

Для выборки данных из БД в MySQL применяется команда SELECT
SELECT список_столбцов FROM имя_таблицы


SELECT столбцы
FROM таблица1
    [INNER] JOIN таблица2
    ON условие1
    [[INNER] JOIN таблица3
    ON условие2]


INNER JOIN

LEFT (OUTER) JOIN

RIGHT (OUTER) JOIN

FULL (OUTER) JOIN 



CROSS JOIN 

Оператор SQL CROSS JOIN формирует таблицу перекрестным соединением (декартовым произведением) двух таблиц. При использовании оператора SQL CROSS JOIN каждая строка левой таблицы сцепляется с каждой строкой правой таблицы. В результате получается таблица со всеми возможными сочетаниями строк обеих таблиц.

SELECT
    column_names [,... n]
FROM
    Table_1 CROSS JOIN Table_2



UNION (ALL)

SELECT_выражение1
UNION [ALL] SELECT_выражение2
[UNION [ALL] SELECT_выражениеN]

UNION позволяет обединить две однотипных выборки. Эти выборки могут быть из разных таблиц или из одной и той же таблицы.
столбцы в выводе должны иметь один тип данных.
оператор ALL - при необходимости  вывода и повторяющихся строк, по умолчанию выводится список без дубликатов.











7. CHAR/VARCHAR			nvarchr

CHAR(n) – n символов, от 1 до 32767, строковый тип фиксированной длины. Если содержимое поля меньше указанного размера, то оно "выравнивается" (добивается) дополнительными пробелами.

VARCHAR(n) – n символов, от 1 до 32767, строковый тип переменной длины. Пробелы в конце содержимого поля игнорируются.

И Char, и Varchar служат символьными типами данных, но varchar используется для строк символов переменной длины, тогда как Char используется для строк фиксированной длины. Например, char(10) может хранить только 10 символов и не сможет хранить строку любой другой длины, тогда как varchar(10) может хранить строку любой длины до 10, т.е. например 6, 8 или 2.

nchar [ ( n ) ]
Строковые данные фиксированного размера. n определяет размер строки в парах байтов и должен быть значением от 1 до 4000. 

nvarchar [ ( n | max ) ]
Строковые данные переменного размера. n определяет размер строки в парах байтов и может быть значением от 1 до 4000. 

Распространенное заблуждение заключается в том, что при использовании nchar(n) и nvarchar(n)n определяет количество символов. Однако в nchar(n) и nvarchar(n)n определяет длину строки в парах байтов (0–4000). n никогда не определяет количество хранимых символов.










8. Каскадные операции


Каскадные обновления и каскадные удаления
При изменении значения первичного ключа таблицы связанные данные во внешних ключах, относящихся к этой таблице, также изменяются, отражая изменения в первичном ключе.
Но так как первичные ключи, как правило, изменяются очень редко, да и с принципе не рекомендуется использовать в качестве первичных ключей столбцы с изменяемыми значениями, то на практике выражение ON UPDATE используется редко.
При удалении записи в таблице, все записи, связанные с этой записью в соответствующих таблицах, автоматически удаляются
каскадные операции устанавливаются при создании таблицы.

синтаксис

CREATE TABLE Orders
(
    Id SERIAL PRIMARY KEY,
    CustomerId INTEGER,
    Quantity INTEGER,
    FOREIGN KEY (CustomerId) REFERENCES Customers (Id) ON DELETE CASCADE
);

С помощью выражений ON DELETE и ON UPDATE можно установить действия, которые выполняются соответственно при удалении и изменении связанной строки из главной таблицы. Для установки подобного действия можно использовать следующие опции:

1. CASCADE: автоматически удаляет или изменяет строки из зависимой таблицы при удалении или изменении связанных строк в главной таблице.
2. RESTRICT: предотвращает какие-либо действия в зависимой таблице при удалении или изменении связанных строк в главной таблице. То есть фактически какие-либо действия отсутствуют.
3. NO ACTION: действие по умолчанию, предотвращает какие-либо действия в зависимой таблице при удалении или изменении связанных строк в главной таблице. И генерирует ошибку. В отличие от RESTRICT выполняет отложенную проверку на связанность между таблицами.
4. SET NULL: при удалении связанной строки из главной таблицы устанавливает для столбца внешнего ключа значение NULL.
5. SET DEFAULT: при удалении связанной строки из главной таблицы устанавливает для столбца внешнего ключа значение по умолчанию, которое задается с помощью атрибуты 6. 6. DEFAULT. Если для столбца не задано значение по умолчанию, то в качестве него применяется значение NULL.










9. ограничения 

ограничения SQL — это правила, применяемые к столбцам данных таблицы. Они используются, чтобы ограничить типы данных, которые могут храниться в таблице. Это обеспечивает точность и надежность данных в базе данных.
Ограничения могут применяться либо на уровне столбцов, либо на уровне таблицы

NOT NULL  — столбец не может иметь значение NULL.

DEFAULT — задает значение по умолчанию для столбца, если оно не указано.

UNIQUE  — все значения в столбце должны быть уникальными.

PRIMARY Key — уникальная идентификация каждой строки/записи в таблице базы данных.

CHECK — проверочное ограничение CHECK обеспечивает, чтобы все значения в столбце удовлетворяли определенным условиям.Например, чтобы ограничить интервал значений столбца salary , можно создать ограничение CHECK, позволяющее столбцу принимать значения только в интервале от 15 000 до 100 000 долларов.



FOREIGN Key —(не является ограничением, это ссылочный тип), уникально идентифицирует строку/запись в любой другой таблице базы данных.









10. ПРЕДСТАВЛЕНИЯ (View)


представления в SQL являются особым объектом, который содержит данные, полученные запросом SELECT из обычных таблиц. Это виртуальная таблица, к которой можно обратиться как к обычным таблицам и получить хранимые данные. Представление в SQL может содержать в себе как данные из одной единственной таблицы, так и из нескольких таблиц.

CREATE OR replace view имя_представления
SELECT ... (из бд, выберает колонки которые будут отображаться в представлении)

представления не влияют на скорость обработки запроса, но нужны для для повышения безопасности и секьюрности (мы обращаемся не ко всем таблицам в бд, а к заранее подгатовленной выборке). Представление создается на основе анализа самых популярных и нужных запросов к бд











11. целостность данных

Под целостностью баз данных будем понимать некоторый набор требований (правил), которые обеспечивают согласованность (непротиворечивость) данных.нарушение которых приведет к противоречию между базой данных  и предметной областью которую она отражает.

набор требований и правил, которые обеспечивают непротиворечивость между бд и рельно существующим обьектом

(непротиворечивость между сущностью в бд и реальным обьектом)

Примеры правил: вес детали должен быть положительным; количество знаков в телефонном номере не должно превышать 15; возраст родителей не может быть меньше возраста их биологического ребёнка и так далее.










12. Что такое таблица?

Данные в СУБД хранятся в объектах БД, называемых таблицами (tables). Таблица, как правило, представляет собой коллекцию связанных между собой данных и состоит из определенного количества колонок и строк.

Таблица — это самая распространенная и простая форма хранения данных в РБД. Вот пример таблицы с пользователями (users):
Каждая таблица состоит из небольших частей — полей (fields). Полями в таблице users являются userId, userName, age, city и status. Поле — это колонка таблицы, предназначенная для хранения определенной информации о каждой записи в таблице.

Запись или строка (record/row) — это любое единичное вхождение (entry), существующее в таблице. В таблице users 5 записей. Проще говоря, запись — это горизонтальное вхождение в таблице.

Колонка (column) — это вертикальное вхождение в таблице, содержащее всю информацию, связанную с определенным полем. В таблице users одной из колонок является city, которая содержит названия городов, в которых проживают пользователи

Таблица — организованный набор данных в виде строк и столбцов. Поле — это столбцы в таблице
















13. вывести текущую дату 

SELECT NOW();               -- 2018-05-25 21:34:55
SELECT SYSDATE();           -- 2018-05-25 21:34:55
SELECT CURRENT_TIMESTAMP(); -- 2018-05-25 21:32:55
возвращают текущую локальную дату и время на основе системных часов в виде объекта datetime.

SELECT CURRENT_DATE();      -- 2018-05-25
SELECT CURDATE();           -- 2018-05-25
возвращают текущую локальную дату в виде объекта date:

SELECT UTC_DATE();      -- 2018-05-25
возвращает текущую локальную дату относительно GMT









14. денормализация данных
Денормализация — намеренное приведение структуры базы данных в состояние, не удовлетворяющее требованиям нормализации
разработчики с целью нахождения компромисса между устранением аномалий и повышением производительности могут не выполнять требования той или иной нормальной формы, более того, они могут прибегать к  денормализации
Например, в процессе эксплуатации базы данных у Вас возникла необходимость добавить новую характеристику, однако по требованиям определенной нормальной формы Вы должны под эту характеристику создать новую таблицу, однако требования предметной области и требования разрабатываемой системы позволяют этого не делать, при этом Вы четко понимаете, что невынесение этих данных в отдельную таблицу положительно скажется на эксплуатации базы данных. В этом случае Вы выполняете как раз денормализацию.
Также денормализация проводится и в процессе проектирования базы данных, например, когда по требованиям той или иной нормальной формы Вы должны выполнить декомпозицию таблицы, а Вы ее намерено не выполняете, все по тем же причинам, т.е. это удовлетворяет Вашим требованиям

процесс проектирования базы данных иногда называют процессом нахождения компромисса между нормализацией и денормализацией, т.е. между устранением аномалий и повышением производительности.

ДЕНОРМАЛИЗАЦИЯ
обратный процесс нормализации для уменьшения времени обработки запросов и увеличения производительности
достигается 2мя способами:
1) обьединение таблиц
2) ввод дополнительного поля в одну из таблиц







15. нормализация данных

нормальная форма базы данных - это набор правил и критериев которым должна отвечать бд
бд считается нормализованной, когда соблюдаются 3 нормальные формы бд (1NF. 2NF. 3NF)
нормализация — это не процесс целенаправленного приведения базы данных к какой-то определенной нормальной форме, нормализация – это набор принципов, зная и следуя которым, мы можем спроектировать базу данных, структура которой будет гарантировать нам отсутствие определенного рода аномалий.
нет требования, которое обязывало бы нас приводить базу данных к максимально возможной нормальной форме, например, к 5 или 6, и не нужно нормализовать базу данных только для того, чтобы она была нормализована.
Максимально нормализованная база данных – это плохая база данных.

Ненормализованная форма или нулевая нормальная форма (UNF) базы данных
строки в таблицах не должны быть пронумерованы, т.е. порядок строк не имеет значения, так же как не имеет значения порядок столбцов. Т.е. например, если мы поменяем порядок столбцов, или порядок строк, ничего измениться не должно, это не должно ни на что повлиять. Таким образом по реляционной теории мы не можем обратиться к определённой строке или столбцу по ее номеру.

нормализация и ее преимущества
Лучшая организация базы данных
Больше таблиц с небольшими строками
Эффективный доступ к данным
Большая гибкость для запросов
Быстрый поиск информации
Проще реализовать безопасность данных
Позволяет легко модифицировать
Сокращение избыточных и дублирующихся данных
Более компактная база данных
Обеспечивает согласованность данных после внесения изменений

1NF
В таблице не должно быть дублирующих строк
В каждой ячейке атомарное значение (одно не составное значение)
В столбце хранятся данные одного типа
Отсутствуют массивы и списки в любом виде

2NF
Таблица должна находиться в первой нормальной форме
Таблица должна иметь ключ
Все неключевые столбцы таблицы должны зависеть от полного ключа (в случае если он составной)

3NF
Требование третьей нормальной формы (3NF) заключается в том, чтобы в таблицах отсутствовала транзитивная зависимость.
Транзитивная зависимость – это когда неключевые столбцы зависят от значений других неключевых столбцов.
иными словами неключевые столбцы должны зависеть от первичного ключа

не всегда нормализация позитивно влияет на производительность БД











16. Сущности в БД

Сущность в базе данных – это любой объект в базе данных, который можно выделить исходя из сути предметной области для которой разрабатывается эта база данных. Разработчик базы данных должен уметь правильно определять сущности.














17. типы индексов.


INDEX 
Индекс – это упорядоченный указатель на записи в таблице.
Индекс – это обьект бд (имеет древовидную структуру), создаваемый с целью повышения скорости поиска данных.
Основная функция индексов - обеспечивать быстрый поиск записи в таблице. Индекс не является частью таблицы - это отдельный объект, связанный с таблицей и другими объектами базы данных

индекс создается автоматически для полей PRIMARY KEY, и ID

Есть три типа индексов, а именно:

Уникальный индекс (Unique Index): этот индекс не позволяет полю иметь повторяющиеся значения, если столбец индексируется уникально. Если первичный ключ определен, уникальный индекс может быть применен автоматически.
Кластеризованный индекс (Clustered Index): этот индекс меняет физический порядок таблицы и выполняет поиск на основе значений ключа. Каждая таблица может иметь только один кластеризованный индекс.
Некластеризованный индекс (Non-Clustered Index): не изменяет физический порядок таблицы и поддерживает логический порядок данных. Каждая таблица может иметь много некластеризованных индексов.

Индекс — это как алфавитный указатель в библиотеке.
Индексы относятся к методу настройки производительности, позволяющему быстрее извлекать записи из таблицы. Индекс создает отдельную структуру для индексируемого поля и, следовательно, позволяет быстрее получать данные.
при обнавлении данных в большом количестве рекомендуется отключать индексацию, а потом ее заново включать, тк это тормозит процесс обработки данных системой

кластерный индекс
Индекс кластера – это тип индекса, который сортирует строки данных в таблице по их ключевым значениям. В базе данных существует только один кластеризованный индекс на таблицу.
Кластерный индекс определяет порядок, в котором данные хранятся в таблице и могут быть отсортированы только одним способом. Таким образом, для каждой таблицы может быть только один кластеризованный индекс. В РСУБД, как правило, первичный ключ позволяет создавать кластерный индекс на основе этого конкретного столбца.

некластеризованный индекс
Некластеризованный индекс хранит данные в одном месте и индексы в другом месте. Индекс содержит указатели на местоположение этих данных. Одна таблица может иметь много некластеризованных индексов, поскольку индекс в некластеризованном индексе хранится в разных местах.\
Например, книга может иметь более одного индекса, один в начале, который отображает содержание книги, а второй индекс показывает индекс терминов в алфавитном порядке.
Некластеризованный индекс определяется в неупорядоченном поле таблицы. Этот тип метода индексации помогает повысить производительность запросов, использующих ключи, которые не назначены в качестве первичного ключа. Некластеризованный индекс позволяет добавить уникальный ключ для таблицы.

Недостаток индексов
изменения в исходной таблице приводит к необходимости изменять все связанные с ней индексы, если индексов много требуется длительное время для обновления индексов (снижение производительности)








18. разница между кластеризованным и некластеризованным индексами в SQL?

индекс - указатель 
Индекс (англ. index) — объект базы данных, создаваемый с целью повышения производительности поиска данных. 
Индекс – это ключ(или таблица), построенный из одного или нескольких столбцов в базе данных, который ускоряет выборку строк из таблицы или представления. 
Индексы — это специальные поисковые таблицы (lookup tables), которые используются движком БД в целях более быстрого извлечения данных. Проще говоря, индекс — это указатель или ссылка на данные в таблице.
Индексы ускоряют работу инструкции SELECT и предложения WHERE, но замедляют работу инструкций UPDATE и INSERT. Индексы могут создаваться и удаляться, не оказывая никакого влияния на данные.
Для создания индекса используется инструкция CREATE INDEX, позволяющая определять название индекса, индексируемые колонки и порядок индексации (по возрастанию или по убыванию).
К индексам можно применять ограничение UNIQUE для того, чтобы обеспечить их уникальность.
Решение о создании индексов для одной или нескольких колонок следует принимать на основе того, какие колонки будут часто использоваться в запросе WHERE в качестве условия для сортировки строк.

Различия между кластеризованным и некластеризованным индексами в SQL:
Кластерный индекс используется для простого и быстрого извлечения данных из базы данных, тогда как чтение из некластеризованного индекса происходит относительно медленнее.
Кластеризованный индекс изменяет способ хранения записей в базе данных — он сортирует строки по столбцу, который установлен как кластеризованный индекс, тогда как в некластеризованном индексе он не меняет способ хранения, но создает отдельный объект внутри таблицы, который указывает на исходные строки таблицы при поиске.
Одна таблица может иметь только один кластеризованный индекс, тогда как некластеризованных у нее может быть много.

Упрощённо некластерный индекс можно представить как отдельную таблицу, каждая строка в которой ссылается на одну или несколько строк в таблице с данными. Строки в индексной таблице упорядочены и сгруппированы по значениям ключевых полей.
не Кластерный индекс — это древовидная структура данных, при которой значения индекса хранятся вместе с данными, им соответствующими. И индексы, и данные при такой организации упорядочены. При добавлении новой строки в таблицу, она дописывается не в конец файла*, не в конец плоского списка, а в нужную ветку древовидной структуры, соответствующую ей по сортировке.

без индексации будет прочитана и проверена каждая строка, и неудовлетворяющие условию строки просто не попадут в результат. Но прочитаны они будут.
При использовании «обычного», некластерного индекса, задача поиска сильно ускоряется. 
1  индексная таблица весит много меньше таблицы с данными, а значит элементарно может быть прочитана быстрее. 
2  СУБД чаще всего стараются кешировать индексы в оперативную память, которая сама по себе много шустрее жёсткого диска*. 
3  в индексах отсутствуют дублирующиеся строки. А значит, как только мы нашли первое значение, поиск можно прекращать — оно же и последнее. 
4  данные в индексе отсортированы. 
А в-третьих и в-четвёртых вместе позволяют использовать алгоритм бинарного поиска (он же метод деления пополам), эффективность которого многократно превосходит простой перебор.

Для оптимальной производительности запросов индексы обычно создаются на тех столбцах таблицы, которые часто используются в запросах. Для одной таблицы может быть создано несколько индексов. Однако увеличение числа индексов замедляет операции добавления, обновления, удаления строк таблицы, поскольку при этом приходится обновлять сами индексы. Кроме того, индексы занимают дополнительный объем памяти, поэтому перед созданием индекса следует убедиться, что планируемый выигрыш в производительности запросов превысит дополнительную затрату ресурсов компьютера на сопровождение индекса


















19. отличия DROP DELETE TRANCATE   (DROP — удаляет, DELETE/TRUNCATE — очищает.)

DROP удаляет таблицу из базы данных целиком, вместе со структурой. То есть после выполнения такой команды обратитья к удаленной таблице, например с помощью SELECT, будет уже нельзя.

TRUNCATE удаляет не саму таблицу, а данные, которые эта таблица содержит. TRUNCATE, из-за невозможности использования условий удаления строк через WHERE и отсутствия связанной с этим необходимости сканирования таблицы, является более быстрым аналогом DELETE. Таким образом использование команды TRUNCATE оправдывает себя при необходимости очистить от данных таблицы, содержащие большое (десятки и сотни тысяч) количество строк

DELETE – удаляет одну или несколько строк из таблицы или представления в Microsoft SQL Server, при этом эта операция всегда полностью регистрируется в журнале транзакций, т.е. каждая удаленная строка.

TRUNCATE быстрее тк не записывает в журнал транзакций удаление каждой строки, а делает одну запись об удалении таблицы
TRUNCATE не будет работать, если таблица содержит внешние ключи. В этом случае придется использовать DELETE.
DROP удаляет саму таблицу, и нельзя сделать Rollback команды, тогда как команда TRUNCATE удаляет все строки из таблицы 

				УДАЛЕНИЕ



DROP TABLE tableName;				удаление таблицы

DROP DATABASE [IF EXISTS] dbName;		удаление БД


TRUNCATE TABLE tableName;			очистка таблицы


ALTER TABLE tableName				удаление колонки из таблицы
DROP COLUMN colName;

ALTER TABLE tableName				удаление индекса
DROP INDEX indexName;


DELETE FROM tableName				удаление определенной записи
WHERE имя_поля=значение;

DELETE FROM tableName;				удалит все значения из таблицы









 



 

20. свойства АСИД (атомарность согласованность изолированность долговечность(стойкость))
ACID (от англ. atomicity, consistency, isolation, durability) 

Требования ACID — набор требований, которые обеспечивают сохранность ваших данных. Что особенно важно для финансовых операций

Atomicity (атомарность)
Атомарность гарантирует, что каждый запрос в транзакции будет выполнен успешно, либо вообще никакой, в случае ошибки одного. Не получится так, что часть запросов выполнятся успешно, а часть с ошибкой. Если хоть одна часть транзакции выполнится с ошибкой, вся транзакция не выполнится. Другими словами под атомарностью можно понимать «всё или ничего».

Consistency (консистентность, согласованность)
Есть такое определение транзакции: «Упорядоченное множество операций, переводящих базу данных из одного согласованного состояния в другое». То есть до выполнения операции и после база остается консистентной (в переводе на русский — согласованной).

Isolation (изолированность)
Гарантирует, что все транзакции будут выполняться изолированно.  Другими словами, одна транзакция не сможет прочитать данные второй транзакции, которая ещё не выполнилась, параллельные транзакции не должны оказывать влияния на её результат.

Durability (стойкость) Надёжность
Если пользователь получил подтверждение от системы, что транзакция выполнена, он может быть уверен, что сделанные им изменения не будут отменены из-за какого-либо сбоя. Обесточилась система, произошел сбой в оборудовании? На выполненную транзакцию это не повлияет.

Транзакция это единая логическая операция, которая может состоять из одного или нескольких шагов. Например, транзакцией может быть перевод денежных средств между банковскими аккаунтами (снятие денег из одного и пополнение другого). Если в середине такой транзакции возникнет ошибка, может возникнуть большая неконсистентность в данных. Деньги будут вычтены с одного счёта, но не зачислены в другой.
Вот тут и должны быть применены принципы ACID.













21. операторы доступные в SQL

Оператор – это зарезервированное слово, или символ, который используется в SQL выражениях с использованием WHERE для выполнения операции или операций, например, сравнение.

арифметические
+
-
*
/
%	делит левое значение на правое от оператора и возвращает остаток от деления.

логические
ALL	Используется для сравнения значения со всеми значениями в другом множестве значений.
AND	Разрешает существование нескольких условий в условии WHERE выражения SQL.
ANY	Сравнивает значение с любым применимым значением в списке в соответствии с условием.
BETWEEN	Ищет значения в указанном диапазоне.
EXISTS	Ищет запись в таблице, которая соответствует заданным критериям.
IN	Сравнивает значение в списке определённых буквенных значений.
LIKE	Сравнивает значение, которое похоже на определённый шаблон.
NOT	Делает логический оператор противоположным. Например, NOT IN, NOT EXISTS и т.д.
OR	Комбинирует несколько условий в SQL выражении.
IS NULL	Сравнивает значение с NULL.
UNIQUE	Проверяет каждую запись в таблице на уникальность.
 
сравнения
=	
!=	
<>	Проверяет, равны ли значения слева и справа от оператора. Если да – возвращает false, если нет – true	(A <> B) – true.
>	
<	
>=	
<=	
!<	Проверяет, чтобы значение слева было не меньше, чем значение справа от оператора. Если да – возвращает true, если нет – false.	(A !< B) – false
!>	Проверяет, чтобы значение слева было не больше, чем значение справа от оператора. Если да – возвращает true, если нет – false.













22. равны ли  NULL   0    и пробел
NULL указывает на то, что значение неизвестно. NULL отличается от пустого или нулевого значения. Два значения NULL считаются эквивалентными. Сравнения между двумя значениями NULL или между значением NULL и каким-либо иным значением возвращают неизвестную величину, так как значение каждого из значений NULL неизвестно.
Значение NULL обычно указывает на то, что данные неизвестны, неприменимы или будут добавлены позже












23. декомпозиция
разделение одной таблицы на несколько











24. подзапросы в SQL. типы подзапросов
Некоррелирующие
Подзапрос, возвращающий результат или результаты, для получения которых значения указанного столбца не должны соотноситься (коррелировать) со значениями столбцов, указанных в основном запросе, называется некоррелирующим. Результат выполнения некоррелирующего запроса не зависит от значений, возвращаемых основным запросом. Обычно некоррелирующие запросы применяются в запросах, в которых значение определённого столбца сравнивается со значением, возвращаемым подзапросом, в запросах с предикатом IN, кванторными функциями ALL и ANY. Однако уже в запросах с предикатом EXISTS применяются коррелирующие подзапросы.

коррелирующие
Подзапрос, возвращающий результат или результаты, для получения которых значения указанного столбца должны соотноситься (коррелировать) со значениями столбцов, указанных в основном запросе, называется коррелирующим. Иными словами, результат, выполнения подзапроса зависит от значений, возвращаемых основным запросом. Часто коррелирующие подзапросы применяются для получения значений одного из столбцов результирующей таблицы

Существует два типа подзапросов, а именно: коррелированные и некоррелированные.
Коррелированный подзапрос: это запрос, который выбирает данные из таблицы со ссылкой на внешний запрос. Он не считается независимым запросом, поскольку ссылается на другую таблицу или столбец в таблице.
Некоррелированный подзапрос: этот запрос является независимым запросом, в котором выходные данные подзапроса подставляются в основной запрос.










25. ANY(SOME), ALL

ALL
При использовании  ALL условие в операции сравнения должно быть верно для всех значений, которые возвращаются подзапросом. 
Например, найдем все товары, цена которых меньше чем у любого товара фирмы Apple:

SELECT * FROM Products
WHERE Price < ALL(SELECT Price FROM Products WHERE Manufacturer='Apple')

можно переписать другим образом:
SELECT * FROM Products
WHERE Price < (SELECT MIN(Price) FROM Products WHERE Manufacturer='Apple')

оператор ALL:
x > ALL (1, 2) эквивалентно x > 2
x < ALL (1, 2) эквивалентно x < 1
x = ALL (1, 2) эквивалентно (x = 1) AND (x = 2)
x <> ALL (1, 2) эквивалентно x NOT IN (1, 2)


ANY
Операторы ANY и SOME условие в операции сравнения должно быть истинным для (хотя бы) одного из значений, возвращаемых подзапросом. По своему действию оба этих оператора аналогичны, поэтому можно применять любой из них. 
Например, в следующем случае получим товары, которые стоят меньше самого дорогого товара компании Apple:

SELECT * FROM Products
WHERE Price < ANY(SELECT Price FROM Products WHERE Manufacturer='Apple')

переписать можно следующим образом:
SELECT * FROM Products
WHERE Price < (SELECT MAX(Price) FROM Products WHERE Manufacturer='Apple')

ANY (а также SOME):
x > ANY (1, 2) эквивалентно x > 1
x < ANY (1, 2) эквивалентно x < 2
x = ANY (1, 2) эквивалентно x IN (1, 2)
x <> ANY (1, 2) эквивалентно (x <> 1) OR (x <> 2)










26. вывести количество строк в таблице базы данных
count()

SELECT COUNT(column_name)
FROM table_name
WHERE condition;









27. Что вы подразумеваете под «триггером» в SQL?

Триггер в SQL — особый тип хранимых процедур, которые предназначены для автоматического выполнения в момент или после изменения данных. Это позволяет вам выполнить пакет кода, когда вставка, обновление или любой другой запрос выполняется к определенной таблице.

Триггеры в SQL

Триггеры по своей сути представляют обработчики событий. Они выполняются при наступлении какого-либо простого действия в SQL. Такими действиями обычно являются: удаление, вставка и обновление данных
Триггер позволяет автоматизировать некоторые расчетные рутинные действия
Возможно 6 вариантов срабатывания тригеров:
BEFORE INSERT
BEFORE UPDATE
BEFORE DELETE
AFTER INSERT
AFTER UPDATE
AFTER DELETE
ПРИМЕР 
Триггер представляет собой хранимую процедуру, которая активизируется при наступлении определенного события. Например, можно задать хранимую процедуру, которая срабатывает каждый раз при удалении записи из транзакционной таблицы - таким образом, обеспечивается автоматическое удаление соответствующего заказчика из таблицы заказчиков, когда все его транзакции удаляются.

триггер который автоматически будет увеличивать новую введенную цену на 20%.









28. Что делают псевдонимы Aliases?

SQL-псевдонимы нужны для того, чтобы дать временное имя таблице или столбцу. Это нужно, когда в запросе есть таблицы или столбцы с неоднозначными именами. В этом случае для удобства в составлении запроса используются псевдонимы. SQL-псевдоним существует только на время запроса.

Пример:

SELECT very_long_column_name AS alias_name
FROM table;









29. Как выбрать записи с нечётными Id?

Один из самых распространённых вопросов на собеседовании. SQL запрос для выбора записей с нечётными id должен выглядеть следующим образом:

SELECT * FROM sample WHERE id % 2 != 0;

Если остаток от деления id на 2 равен нулю, перед нами чётное значение, и наоборот.










30. Выберите только уникальные имена

SELECT DISTINCT name FROM users;

SELECT DISTINCT возвращает разные значения, даже если в выбранном столбце есть дубли.










31. Переименуйте таблицу

ALTER TABLE first_table RENAME second_table;

С помощью оператора ALTER TABLE можно добавлять, удалять, изменять столбцы, а также изменять название таблицы.







32. Что такое нулевое значение?

Нулевое значение (NULL) — это значение поля, которое является пустым, т.е. нулевое значение — это значение поля, не имеющего значения. Важно понимать, что нулевое значение отличается от значения 0 и от значения поля, содержащего пробелы (`). Поле с нулевым значением - это такое поля, которое осталось пустым при создании записи. Также, следует учитывать, что в некоторых СУБД пустая строка ('') — этоNULL`, а в некоторых — это разные значения.










33. Транзакции


Транзакция - последовательность команд в SQL, которые должны выполнится полностью или не выполниться совсем

Транзакция — это единица работы или операции, выполняемой над БД. Это последовательность операций, выполняемых в логическом порядке. Эти операции могут запускаться как пользователем, так и какой-либо программой, функционирующей в БД.
Транзакция — это применение одного или более изменения к БД. Например, при создании/обновлении/удалении записи мы выполняем транзакцию. Важно контролировать выполнение таких операций в целях обеспечения согласованности данных и обработки возможных ошибок.
На практике, запросы, как правило, не отправляются в БД по одному, они группируются и выполняются как часть транзакции.
Свойства транзакции
Транзакции имеют 4 стандартных свойства (ACID):
атомарность (atomicity)
согласованность (consistency) 
изолированность или автономность (isolation)
долговечность, надежность (durability) 

ТРАНЗАКЦИИ
Транзакция - логическая единица работы в базе данных а так же единица восстановления информации при сбое СУБД. При фиксации изменений в базе данных гарантируется сохранение либо всех изменений, либо ни одного. Более того, выполняются все правила и проверки, обеспечивающие целостность данных.
Транзакции базы данных обладают свойствами, сокращенно называемыми ACID
Все команды, выполняемые пользователями на сервере, производятся в теле транзакций. Однако существует два подхода к указанию границ транзакций в потоке команд - явные и неявные транзакции.

Явные транзакции. По умолчанию, каждая команда выполняется как отдельная транзакция. Пользователь может объединить несколько команд в одну транзакцию, явно указав ее начало и конец.

Неявные транзакции. Не существует оператора начала транзакции. Транзакция начинается с началом сеанса работы с БД. Завершается транзакция при следующих событиях:
	Явно выполненный оператор завершения транзакции - rollback или commit
	Оператор DDL
	Завершение сеанса.
	После окончания транзакции сразу неявно начинается новая транзакция










34. СУБД

Существует две модели СУБД - реляционная (на основе SQL(PostgreSQL. MySQL. SQLite.)) и безсхемная(NoSQL (NO only SQL. не только SQL) 
DynamoDB, Redis, DB2, Microsoft Access). 
Безсхемные СУБД основанные на принципах неструктурированного подхода избавляют программиста 
от проблем реляционной модели, в число которых входит низкая производительность и 
трудное масштабирование данных в горизонтальном формате.




 





35.	Сравнение SQL и NoSQL
 

NoSQL
Неструктурированные(безсхемные) базы данных (NoSQL) создают структуру по ходу и 
убирают необходимость в создании жёстко определённых связей между данными. 
Здесь можно экспериментировать с разными способами доступа к тем или иным видам данных.
По принципу NoSQL работает база данных MongoDB. Они хранят все данные как единое целое в одной базе. 
При этом данные могут быть и одиночным объектом, но в то же время любой запрос не останется без ответа.
Каждая NoSQL имеет собственную систему запросов, что требует дополнительного изучения данной системы.

Если SQL-системы основаны исключительно на строгом представлении данных, 
то NoSQL-системы предоставляют свободу и способны работать с любым типом данных.

SQL-системы стандартизированы, за счёт чего запросы формируются с использованием языка SQL. 
В то же время NoSQL-системы базируются на специфической для каждой из них технологии, 
что является недостатком.

Масштабируемость. Обе СУБД способны обеспечить вертикальное масштабирование, то есть увеличить 
объём системных ресурсов на обработку данных. При этом NoSQL, будучи более новой разновидностью 
баз данных, позволяет применять простые методы горизонтального масштабирования.

В плане надёжности SQL обладает уверенным лидерством.

У SQL-баз есть качественная техническая поддержка за счёт их продолжительной истории, 
в то время как NoSQL-системы весьма молоды и и решить какую-либо проблему сложнее.

Хранение данных и доступ к их структурам в рамках реляционных систем лучше 
всего происходит в SQL-системах.

Таким образом, хоть NoSQL и является стремительно развивающейся разновидностью систем 
управления базами данных, однако на данном этапе рекомендуется остановить свой выбор на SQL.
Надёжность SQL-систем, особенно MySQL, подтверждается временем и массовостью. 
Сегодня любой уважающий себя ресурс использует для хранения данных именно систему MySQL.








36. Хранимые процедуры 

(аналог alias. только для селектов и др команд)
Хранимые процедуры представляют собой набор команд SQL, которые могут компилироваться и храниться на сервере. Таким образом, вместо того, чтобы хранить часто используемый запрос, клиенты могут ссылаться на соответствующую хранимую процедуру. Это обеспечивает лучшую производительность, поскольку данный запрос должен анализироваться только однажды и уменьшается трафик между сервером и клиентом. Концептуальный уровень можно также повысить за счет создания на сервере библиотеки функций.
Это может быть полезным тогда, когда:
многочисленные приложения клиента написаны в разных языках или работают на других платформах, но нужно использовать ту же базу данных операций
безопасность на 1 месте
Хранимые процедуры и функции (подпрограммы) могут обеспечить лучшую производительность потому, что меньше информации требуется для пересылки между клиентом и сервером. Выбор увеличивает нагрузку на сервер БД, но снижает затраты на стороне клиента. 
В отличие от хранимых функций в хранимые процедуры  СУБД позволяют формировать и выполнять ди-
намические SQL-запросы.
• выполнять динамические запросы и помещать результаты их работы в пере-
менные можно только с использованием т.н. «сессионных переменных» 
(имена которых начинаются со знака @);
• имена переменных, в которые помещается результат выполнения запроса, 
не должны совпадать с именами параметров хранимой процедуры (и, в не-
которых случаях, с именами полей, возвращаемых запросом).









37. тип хранения данных MyISAM или InnoDB


InnoDB
Он обеспечивает функцию управления транзакциями. Он гарантирует, что набор команд выполняется успешно или, когда в любой из команд возникает ошибка, результаты всех команд откатываются, что можно представить в электронном банке!был спроектирован для обработки транзакций, в частности для большого количества короткоживущих транзакций, которые чаще комитятся чем откатываются.

MyISAM 
он разработан с учетом того, что количество запросов к базе данных намного больше, чем количество обновлений. Таким образом, ISAM выполняет операции чтения очень быстро и не занимает много памяти и ресурсов хранения. Два основных недостатка ISAM:Он не поддерживает обработку транзакций и не может быть отказоустойчивым.: Если ваш жесткий диск выходит из строя, файлы данных не могут быть восстановлены. 










38. Что такое уникальный ключ (Unique key)?


Однозначно идентифицирует одну строку в таблице.
Допустимо множество уникальных ключей в одной таблице.
Допустимы NULL-значения (прим. перевод.: зависит от СУБД, в SQL Server значение NULL может быть добавлено только один раз в поле с UNIQUE KEY).














39. Что такое сущности и отношения?


Сущности: человек, место или объект в реальном мире, данные о которых могут храниться в базе данных. В таблицах хранятся данные, которые представляют один тип сущности. Например — база данных банка имеет таблицу клиентов для хранения информации о клиентах. Таблица клиентов хранит эту информацию в виде набора атрибутов (столбцы в таблице) для каждого клиента.


Отношения: отношения или связи между сущностями, которые имеют какое-то отношение друг к другу. Например — имя клиента связано с номером учетной записи клиента и контактной информацией, которая может быть в той же таблице. Также могут быть отношения между отдельными таблицами (например, клиент к счетам).













40. изменение данных в таблице


alter table ...		изменить таблицу (вставить/удалить колонку, добавить ограничение)
(add column,
drop column, 
rename column ... to,
rename to )

ALTER TABLE products 
ADD FOREIGN KEY (product_group_id) REFERENCES product_groups (id);

переименовать колонку
ALTER TABLE имя_таблицы RENAME COLUMN имя_колонки TO новое_имя_колонки

удалить колонку 
ALTER TABLE имя_таблицы DROP COLUMN имя_колонки ;

добавить колонку
ALTER TABLE имя_таблицы ADD COLUMN имя_колонки тип_данных_колонки ;

переименовать таблицу
ALTER TABLE имя_таблицы RENAME TO новое_имя_таблицы



insert INTO ...		добавить/вставить данные в таблицу (внести данные в строку)
values ()



update имя_таблицы ...	обновить данные в таблице (заменить данные в строках)
set столбец = значение, столбец = значение ...
(where)















41. операторы CRUD в SQL


CREATE
SELECT
INSERT INTO
ALTER TABLE
DROP/DELETE











42. агрегатные ф-ии 

Агрегатные функции вычисляют одно значение над некоторым набором строк. 
В качестве параметра все агрегатные функции принимают выражение, которое представляет критерий для определения значений. Зачастую, в качестве выражения выступает название столбца, над значениями которого надо проводить вычисления.
Если в наборе нет строк, то все агрегатные функции за исключением COUNT(*) возвращают значение NULL.

В PostgreSQL имеются следующие агрегатные функции:

AVG: находит среднее значение. Входной параметр должен представлять один из следующих типов: smallint, int, bigint, real, double precision, numeric, interval. Для целочисленнных параметров результатом будет значение типа numeric, для параметров, которые представляют число с плавающей точкой, - значение типа double precision.

COUNT(*): находит количество строк в запросе

COUNT(expression): находит количество строк в запросе, для которых expression не содержит значение NULL.

SUM: находит сумму значений

MIN: находит наименьшее значение

MAX: находит наибольшее значение
BIT_AND: выполняет операцию побитового умножения (операции логического И) для чисел следующих типов: smallint, int, bigint, bit. Если параметр содержит значение NULL, то возвращается NULL.


STRING_AGG(expression, delimiter): соединяет с помощью delimiter все текстовые значения из expression в одну строку.

BIT_OR: выполняет операцию побитового сложения (операции логического ИЛИ) для чисел следующих типов: smallint, int, bigint, bit. Если параметр содержит значение NULL, то возвращается NULL.

BOOL_AND: выполняет операцию логического умножения для значений типа bool. Если входные все значения равны true, то возвращается true, иначе возвращается false.

BOOL_OR: выполняет операцию логического сложения для значений типа bool. Если входные хотя бы одно из значений равно true, то возвращается true, иначе возвращается false.
















43. Операторы фильтрации

SELECT * FROM Products
WHERE Manufacturer [NOT] IN ('Samsung', 'HTC', 'Huawei');		
Выражение в скобках после IN определяет набор значений


SELECT * FROM Products
WHERE Price BETWEEN 20000 AND 50000;				
Оператор BETWEEN определяет диапазон значений с помощью начального и конечного значения, которому должно соответствовать выражение:


SELECT * FROM Products
WHERE ProductName LIKE 'iPhone%';
Оператор LIKE принимает шаблон строки, которому должно соответствовать выражение.













44. 













=============================================================================================================


BACKUP DB

маштабирование бд (sharding, replication)

order by параметр 


















